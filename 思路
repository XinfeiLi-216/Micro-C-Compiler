# Solved 优先级问题
# TODO exp值的计算

5.1:
    1. 语句主要有以下几类：
    a. 赋值和声明语句 {每个变量的地址都在编译期确定}
    b. 条件语句 if while do while
    c. read和write语句
    d. 没有什么用的return语句
    e. 重要成分之exp 所有的计算都是在exp内部完成的 {模拟递归}

    2. 基本思路：
    维护一个Variable Table来记录所有的变量名 类型和值 而且包括了imm看看作业1的代码还能
    用不能 先设计一个支持exp write scanf assign的出来

    3. exp计算思路：
    exp是递归的 这造成了对寄存器分配的麻烦 如果匹配到最小部分就是数字和数字的运算这部
    分直接分配$s0,$s1,$s2给运算数字和结果就好
    如果遇到exp+exp的情况 就麻烦一点 因为要得到两个子exp的值 那么寄存器就可能不够用
    因为子式是可能无限多的 那就要在不够用的时候存到内存里 这里需要一个分配+处理的算法

    #处理算法
    首先变量替换 如果是已知的变量/可以算出来的值 就直接处理掉 那么就需要Symbol Table 
    这里只需要记录变量名和值 imm不用记录 直接原地处决 那么temp变量怎么办?

5.2:
    1. 暂时生成毫不优化的代码 只用三个寄存器 因为exp每次都进到最深层 
    对所有exp及其子exp 存储值到heap中 现在的问题在于普通变量和exp变量同时存在使得exp的
    count难以决定
    2. exp和普通变量共存的问题解决 单独用storage_set来记录index和value 另有count来计算
    当前exp变量的总数 共有两组hashtable来分别记录变量的值和exp的值 其中exp以count来索引
    变量用变量名来索引
    3. 另一问题是exp的值的计算 因为exp是递归匹配的 可以等同于dfs 当匹配到最深层的时候
    一定是数字 故而可以由底向上确定exp的值 但要考虑到Variable的出现以及匹配过程怎么处理
    4. 大体思路确定 用枚举量传入当前的operator 然后对当前值以及operator2(也就是当前值)
    右侧的值进行合并 依次继续 
    # TODO 什么时候停下？ 正确性有待判断 怎么传回bison?

5.3:
    1. exp中没有变量声明的可能 故而exp所占据的空间可以向后直接延伸 每个exp所指向的地址
    都将由index来指向 即每个变量/exp的空间都在编译期确定了 如果当前的exp是binary operator
    运算的话 对当前count指向和下一个位置的指向做对应的operation 如果是unary operator的话 
    对下一位置做对应operation?
    2. 故而能对整体程序做一个总结 每一个exp和variable都可以被索引到 exp用count variable用
    名字就好 但是在其他部分遇到exp如何得到count还是一个问题 应该直接取最大的就好 #TODO
    3. 首先把exp里的部分处理完 
    4. 进展很好 感觉exp已经不是大问题了 但现在已经牵涉到生成代码的部分了 又开了一个类
    5. 此外 需要开始思考 if while dowhile 这些怎么处理了
