# Solved 优先级问题
# TODO exp值的计算

5.1:
    1. 语句主要有以下几类：
    a. 赋值和声明语句
    b. 条件语句 if while do while
    c. read和write语句
    d. 没有什么用的return语句
    e. 重要成分之exp 所有的计算都是在exp内部完成的

    2. 基本思路：
    维护一个Variable Table来记录所有的变量名 类型和值 而且包括了imm看看作业1的代码还能
    用不能 先设计一个支持exp write scanf assign的出来

    3. exp计算思路：
    exp是递归的 这造成了对寄存器分配的麻烦 如果匹配到最小部分就是数字和数字的运算这部
    分直接分配$s0,$s1,$s2给运算数字和结果就好
    如果遇到exp+exp的情况 就麻烦一点 因为要得到两个子exp的值 那么寄存器就可能不够用
    因为子式是可能无限多的 那就要在不够用的时候存到内存里 这里需要一个分配+处理的算法

    #处理算法
    首先变量替换 如果是已知的变量/可以算出来的值 就直接处理掉 那么就需要Symbol Table 
    这里只需要记录变量名和值 imm不用记录 直接原地处决 那么temp变量怎么办？

5.2:
    1. 暂时生成毫不优化的代码 只用三个寄存器
    对所有exp及其子exp 存储值到heap中 现在的问题在于普通变量和exp变量同时存在使得exp的
    count难以决定

5.3:
    1. exp和普通变量共存的问题解决 单独用storage_set来记录index和value 另有count来计算
    当前exp变量的总数 共有两组hashtable来分别记录变量的值和exp的值 其中exp以count来索引
    变量用变量名来索引
    2. 另一问题是exp的值的计算 因为exp是递归匹配的 可以等同于dfs 当匹配到最深层的时候
    一定是数字 故而可以由底向上确定exp的值 但要考虑到Variable的出现以及匹配过程怎么处理
    3. 大体思路确定 用枚举量传入当前的operator 然后对当前值以及operator2(也就是当前值)
    右侧的值进行合并 依次继续 
    # TODO 什么时候停下？ 正确性有待判断 怎么传回bison？
